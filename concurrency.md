# Концепции параллелизма, многопоточности и параллельного программирования

# Содержание
#### Подходы к параллелизму
* Processes
* Threads

#### Способы синхронизации
* Locks
* Mutex
* Semaphores



## Processes

Процессы управляются операционной системой (ОС), и в случае современной ОС они действительно параллельны при наличии подходящей аппаратной поддержки (многопроцессорные и многоядерные системы).

Процессы планируются планировщиком операционной системы. Они могут состоять из нескольких потоков выполнения, которые выполняют инструкции одновременно.

Процессы существуют в своем собственном адресном пространстве. Ни один другой процесс не может вмешаться в память другого, потому что ОС обеспечивает это с помощью изоляции процессов, поскольку именно ОС управляет процессами.

Процессы очень требовательны, и запускать многие из них (в отличие от других моделей параллелизма) не рекомендуется. Для создания процесса требуется создать совершенно новое виртуальное адресное пространство.

Переключение контекста между процессами требует много работы. Это означает сохранение всего состояния процессора (всех используемых регистров процессора, счетчика программ и т.д.)

Процессы не могут взаимодействовать друг с другом напрямую (в современных ОС). Вместо этого ОС предоставляет средства для межпроцессного взаимодействия.

Типичные способы межпроцессного взаимодействия включают файлы, сигналы, сокеты, очереди сообщений, semaphores. 

Все процессы основаны на упреждающей многозадачности, что означает, что операционная система решает, когда процесс будет вытеснен ("перейдет в спящий режим") и какой процесс будет "активирован" следующим.


## Threads

Потоки, как и процессы, также управляются ОС. Потоки используют одно и то же адресное пространство своего родительского процесса. Это означает, что процессы могут создавать потоки косвенно, используя функциональность, предоставляемую ОС.

На одном процессоре многопоточность обычно осуществляется путем мультиплексирования с разделением по времени (как в многозадачности): процессор переключается между разными потоками. Это переключение контекста обычно происходит достаточно часто, чтобы пользователь воспринимал потоки или задачи как выполняющиеся одновременно. В многопроцессорной системе (включая многоядерную систему) потоки или задачи фактически будут выполняться одновременно, причем каждый процессор или ядро выполняет определенный поток или задачу.

Многие современные операционные системы напрямую поддерживают как распределенную по времени, так и многопроцессорную многопоточность с помощью планировщика процессов.

Как и процессы, потоки предназначены для преимущественной многозадачности, и ОС решает, когда они будут вытеснены. Чтобы избежать вытеснения потоками, можно использовать mutex.

Взаимодействие между потоками намного проще, чем межпроцессное взаимодействие между процессами. В основном это связано с общей памятью, но также и с тем фактом, что строгие ограничения безопасности, которые операционная система накладывает на процессы, не существуют для потоков.

#### Использование памяти

Обычно говорят, что потоки "легкие", но это относительно. Потоки должны поддерживать выполнение машинного кода, поэтому ОС должна предоставлять стек приличного размера, обычно измеряемый в мегабайтах. В Windows размер резервирования стека по умолчанию, используемый компоновщиком, равен 1 МБ. В Linux типичный размер стека потоков составляет от 2 МБ до 10 МБ. Это означает, что в Linux создание 1000 потоков равнялось бы использованию памяти от ~2 ГБ до ~10 ГБ, даже не начиная выполнять какую-либо фактическую работу с потоками.

#### "Потоки "легкие""
Потоки - это "облегченные процессы", а не "легкие" сами по себе, как могут утверждать некоторые. Они требуют меньше ресурсов для создания и переключения контекста, в отличие от процессов, но по-прежнему обходится недешево, если многие из них выполняются одновременно.

Хотя переключение контекста потоков по-прежнему включает восстановление счетчика программ, регистров процессора и других потенциальных данных операционной системы, им не требуется переключение контекста MMU, в отличие от процессов, поскольку потоки используют одну и ту же память. Переключение контекста потоками представляет меньшую проблему, если у вас не много потоков.

#### Race conditions

Поскольку память/данные совместно используются потоками в одном и том же процессе, приложениям часто приходится иметь дело с "Race conditions". Необходима синхронизация потоков. Типичные механизмы синхронизации включают Locks, Mutex и Semaphores.Это конструкции параллелизма, используемые для обеспечения того, чтобы два потока не получали доступ к одним и тем же общим данным одновременно, обеспечивая таким образом корректность.

Использование потоков связано с опасными "Race conditions", взаимоблокировками и активными блокировками.

#### Обобщая
Потоки хороши для параллельной интенсивной работы ЦП на 1-n процессорах и ядрах в рамках одного приложения /процесса. Это потому, что они масштабируются до ядер и процессоров благодаря планировщику операционной системы. Для тяжелой работы с вводом-выводом потоки - это кошмар, потому что это обычно включает в себя создание нескольких потоков на более короткие промежутки времени.

## Locks

Locks обычно являются используются, когда каждый поток взаимодействует, получая блокировку перед доступом к соответствующим данным. Большинство конструкций Locks блокируют выполнение потока, запрашивающего ресурс, до тех пор, пока ему не будет разрешен доступ к заблокированному ресурсу. Спин-блокировка - это блокировка, при которой поток просто ожидает ("вращается"), пока блокировка не станет доступной. Это очень эффективно, если потоки, будут заблокированы только на короткий период времени, поскольку позволяет избежать накладных расходов на перепланирование процессов операционной системы. Это расточительно, если блокировка удерживается в течение длительного периода времени. Неосторожное использование блокировок может привести к взаимоблокировке или активной блокировке. Во многих языках программирования блокировки являются самым простым в использовании механизмом синхронизации.


## Mutex

Mutex предотвращает одновременное выполнение блока кода более чем одним потоком одновременно. На самом деле название "Mutex" является сокращенной формой термина "mutually exclusive"(взаимоисключающий). Mutex может использоваться для синхронизации потоков между процессами. При использовании для межпроцессной синхронизации mutex называется именованным мьютексом, поскольку он должен использоваться в другом приложении, и, следовательно, он не может быть совместно использован посредством глобальной или статической переменной. Ему должно быть присвоено имя, чтобы оба приложения могли обращаться к одному и тому же объекту мьютекса. Mutex, в отличие от Locks, могут использоваться для межпроцессной синхронизации.


## Semaphores

Semaphores - это переменная или абстрактный тип данных, который обеспечивает простую, но полезную абстракцию для управления доступом нескольких процессов к общему ресурсу в среде параллельного программирования. Таким образом, семафоры используются не для **внутрипроцессной** синхронизации, а только **межпроцессной** синхронизации. Semaphore - это, по сути, запись о том, сколько единиц определенного ресурса доступно, в сочетании с операциями по безопасной (т.е. без "Race conditions") корректировке этой записи по мере того, как единицы требуются или становятся свободными, и при необходимости подождите, пока единица ресурса не станет доступной.

Семафоры, которые допускают произвольное количество ресурсов, называются **счетными семафорами**, в то время как семафоры, которые ограничены значениями 0 и 1 (или заблокированы/разблокированы, недоступны/доступны в наличии), называются **двоичными семафорами**. Mutex - это, по сути, то же самое, что двоичный семафор, и иногда использует ту же базовую реализацию. Однако термин "Mutex" используется для описания конструкции.
